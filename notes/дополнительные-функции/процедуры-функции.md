## Хранимые процедуры за / против.

За:
 - Код исполняется там, где находятся данные, поэтому можно сэкономить на стевеом трафике и уменьшить время задержки.

 - Это одщна из форм повторного использовани кода.
   Она помогает содержать бизнес правила в одном месте, что обеспечивает согласованное поведение и позволяет избежать лишних требований.

 - Это положительно сказывается на безопасности и позволяет более точно управлять привелегиями. 
   Типичный пример - хранимая процедура для перевода средст с одного банковского счета на другой; она выполняет операцию
   в контексте транзакции и протоколировать ее для последующего аудита. Можно дать приложению право вызывать хранимые процедуру, не открывая
   доступ к используемым в ней таблицам.

 - Сервер кэширует планы выполнения хранимых процедур, что снижает накладные расходы на повторные вызовы.

 - Поскольку код содержится на сервере, его можртывать, включать в резервную копию и сопровождать средствами сервера.
   Поэтому хранимый код хорошо приспособлем для задач обсулживания базы данных. У него нет никаких внешних зависимостей, например от библиотек
   на эзыке Perl или другого программного обеспечения, которое по тем или иным причинам нежелательно устанавливать на сервере.

 - Это способствует разделению труда между программистами приложений баз данных. Лучше, когда хранимые процедуры пишет 
   специалист по базно развеам данных, поскольку не всякий прикладной программист умеет создавать эффективные SQL-запросы.

Против:
 - Вместе с MySQL не поставляются хорошие инструменты разработки и отладки, поэтому писать хранимый код для MySQL труднее, чем для других субд.

 - Сам язык медленный и примитивный по сравнению с прикладными языками.
   Количество доступных функций ограничено, программировать сложные менипуляции со строками и нетривильную логику затруднительно.

 - Наличие хранимого кода может даже усложнить развертывание приложения. 
   Приходится не только вносить изменния в саму программу и схему базы данных, но и развертывать код, хранящийся внутри сервера.

 - Поскольку хранимые подпрограммы содержатся в базе данных, могут возникнуть дополнительные уязвимости. например, 
   реализация нестандартных криптографических функций в хранимой подпрогрмамме не защитит ваши данные в случае компрометации базы. 
   Если бы криптографическая функция была реализована в коде приложения, то хакеру пришлось бы взломать как этот код, так и базу данных.

 - Хранимые подпрограммы увеличивают нагрузку на сервер баз данных, а его обычно труднее масштабировать, чем веб-серверы или серверы приложений.

 - MySQL предлагает весьма скромные средства контроля над ресурсами, 
   выделяемыми для исполнения хранимого кода, поэтому ошибка может привести к отказу всего сервера.

 - Реализация хранимого кода в MySQL довольно ограничена - планы выполнения кэшируются на уровне соединения, 
   курсоры материализуются в виде переменных таблиц и так далее. 
   Мы еще расскажем об ограничениях, присущих отдельным средствам, когда будем их описывать.

 - Код хранимых процедур в MySQL трудно профилировать. Сложно проанлизировать журнал медленных запросов, когда вы видите
   в нем лишь запись CALL XYZ('A'), поскольку придется найти соответсвующую процедуру и изучить все команды в ней.

 - Хранимый код скрывает сложность; это упрощает разработку, но зачастую пагубно отражается на производительности.

Хранимые процедуры и функции

Архитектура MySQL и оптимизатора запросов налагает определенные ограничения на способы использования хранимых
подпрограмм и степень их эффективности. 

 - Для каждого соединения (connection) ведется отдельный кэш планов выполнения хранимых процедур. 
   Если одна и та же процедура вызываевается в нескольких соединенияз, то ресурсы расходуются впустую на кэширование одно
   и того же плана. При использовании пула соединений или постоянных соединений (persistent connection) полезная жизнь плана 
   выполнения может продлиться дольше.
 - Хранимые процедуры плохо сочетаются с репликацией. Возможно, вы хотите реплицировать не выхов процедуры, а лишь сами изменния в наборе данных. 

 Мы обычно предпочтитаем писать небольшие, простые хранимые процедур. На наш взгляд, слодную логику лучше оставить вовне базы данных и реализоватвыть ее 
 с помощью более выразительного и гибкого процедруного языка. К тому же он может открыть доступ к большему обьему вычислительных ресурсов и потенциально
 позволяет реализовать различные формы кжширования.

 Однако для некоторых операций хранимые процедуры могут окащаться гораздо быстрее, особенно если речь идет о мелких запросах. Если запрос достаточно мал, то накладные расходы на его разбор и передачу по сети занимают заметнуюю долю всего времени обработки. Чтобы доказать это, мы написали простенькую 
 хранимую процедуру, которая вставляет в таблицу заданное количество строк. 

 ```sql
DROP PROCEDURE IF EXISTS insert_many_rows;

delimiter //

CREATE PROCEDURE insert_many_rows (IN llops INT)
BEGIN
  DECLARE v1 INT;
  SET v1=loops;
  WHILE v1 > 0 DO
    INSERT INTO test_table values (NULL, 0, 'qwert', 'trewq');
    SET v1 = v1 - 1;
  END WHILE;
END;
//

delimiter;
```

Затем мы сравнили время вставки миллиона строк с помощью этой процедуры и последовательной вставки из клиентского приложения.

Метод                             |  Общее время, сек
------------------------------------------------------
Хранимая процедура                | 101
Клиентское приложение             | 279
Клиенстское приложение            | 307
с соединением через MySQL Proxy

Хранимая процедура работает гораздо быстрее, главным образом из-за
отсутсвия накладных расходов на передачу по сети, разбор, оптимизацию